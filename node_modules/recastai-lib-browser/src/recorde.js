import config from './config.js'
import recastai from 'recastai'

function startRec(param) {
  return new Promise((resolve, reject) => {
    if (!navigator.getUserMedia) {
      navigator.getUserMedia = (navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia ||
        navigator.msGetUserMedia)
    }
    if (navigator.getUserMedia) {
      navigator.getUserMedia({ audio: true }, (stream) => {
        param.webSocket.audioTracks = stream
        param.webSocket.ws = new WebSocket(config.route)
        param.webSocket.ws.onopen = () => {
        param.webSocket.ws.send(JSON.stringify(['authorization', param.userToken]).toString())
        }
        param.webSocket.ws.onmessage = (evt) => {
          const response = JSON.parse(evt.data)
          if (response.step === 'authorization' && response.status === 'OK') {
            if (param.webSocket.audioContext === null ||
              param.webSocket.audioInput === null ||
              param.webSocket.recorder === null) {
              param.webSocket.audioContext = new AudioContext()
              param.webSocket.audioInput = param.webSocket.audioContext.createMediaStreamSource(stream)
              param.webSocket.recorder = param.webSocket.audioContext.createScriptProcessor(4096, 1, 1) ||
              param.webSocket.audioContext.createJavascrciptNode(4096, 1, 1)
            }
            param.webSocket.recorder.onaudioprocess = (e) => {
              if (param.debug === true) { console.log('Recording') }
              if (param.webSocket.recording) {
                if (param.webSocket.ws.readyState === 1) {
                  const float32s = e.inputBuffer.getChannelData(0)
                  param.webSocket.ws.send(float32s.toString())
                }
              }
            }
            param.webSocket.audioInput.connect(param.webSocket.recorder)
            param.webSocket.recorder.connect(param.webSocket.audioContext.destination)
            if (!param.webSocket.recording) {
              param.webSocket.recording = true
            }
          } else if (response.step === 'action' && response.type === 'analyze') {
            if (response.status === 'OK') {
              response.results = response.message
              const res1 = new recastai.Response(response)
              resolve(res1)
            } else if (response.status === 'KO') {
              reject(JSON.stringify(response.message))
            }
          } else if (response.status === 'KO') {
            if (response.step === 'request') {
              param.webSocket.recording = false
              param.webSocket.audioInput.disconnect(param.webSocket.recorder)
              param.webSocket.recorder.disconnect(param.webSocket.audioContext.destination)
              param.webSocket.audioContext.close()
              param.webSocket.audioContext = null
              param.webSocket.audioInput = null
              param.webSocket.recorder = null
              reject(JSON.stringify(response.message))
            }
          }
        }
      }, () => {
        reject('Your microphone is not reachable.')
      })
    //  navigator
    }
  })
}

function stopRec(param) {
  if (!param.webSocket.audioInput) {
    if (param.debug === true) { console.log('you need to start the process before stoping it ') }
  } else {
    if (param.debug === true) { console.log('Stop Recording') }
    param.webSocket.recording = false
    param.webSocket.audioInput.disconnect(param.webSocketrecorder)
    param.webSocket.recorder.disconnect(param.webSocket.audioContext.destination)
    param.webSocket.audioContext.close()
    param.webSocket.audioContext = null
    param.webSocket.audioInput = null
    param.webSocket.recorder = null
    param.webSocket.audioTracks.getAudioTracks()[0].stop();

    if (param.language !== 'en' && param.language !== 'fr') {
      param.language = 'en'
    }
    param.webSocket.ws.send(JSON.stringify(['action', 'analyze', param.language]).toString())
    param.webSocket.ws.onclose = () => {
      param.webSocket.ws.close()
    }
  }
}

module.exports = {
  startRec,
  stopRec,
}
