'use strict';

var _config = require('./config.js');

var _config2 = _interopRequireDefault(_config);

var _recastai = require('recastai');

var _recastai2 = _interopRequireDefault(_recastai);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function startRec(param) {
  return new Promise(function (resolve, reject) {
    if (!navigator.getUserMedia) {
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
    }
    if (navigator.getUserMedia) {
      navigator.getUserMedia({ audio: true }, function (stream) {
        param.webSocket.audioTracks = stream;
        param.webSocket.ws = new WebSocket(_config2.default.route);
        param.webSocket.ws.onopen = function () {
          param.webSocket.ws.send(JSON.stringify(['authorization', param.userToken]).toString());
        };
        param.webSocket.ws.onmessage = function (evt) {
          var response = JSON.parse(evt.data);
          if (response.step === 'authorization' && response.status === 'OK') {
            if (param.webSocket.audioContext === null || param.webSocket.audioInput === null || param.webSocket.recorder === null) {
              param.webSocket.audioContext = new AudioContext();
              param.webSocket.audioInput = param.webSocket.audioContext.createMediaStreamSource(stream);
              param.webSocket.recorder = param.webSocket.audioContext.createScriptProcessor(4096, 1, 1) || param.webSocket.audioContext.createJavascrciptNode(4096, 1, 1);
            }
            param.webSocket.recorder.onaudioprocess = function (e) {
              if (param.debug === true) {
                console.log('Recording');
              }
              if (param.webSocket.recording) {
                if (param.webSocket.ws.readyState === 1) {
                  var float32s = e.inputBuffer.getChannelData(0);
                  param.webSocket.ws.send(float32s.toString());
                }
              }
            };
            param.webSocket.audioInput.connect(param.webSocket.recorder);
            param.webSocket.recorder.connect(param.webSocket.audioContext.destination);
            if (!param.webSocket.recording) {
              param.webSocket.recording = true;
            }
          } else if (response.step === 'action' && response.type === 'analyze') {
            if (response.status === 'OK') {
              response.results = response.message;
              var res1 = new _recastai2.default.Response(response);
              resolve(res1);
            } else if (response.status === 'KO') {
              reject(JSON.stringify(response.message));
            }
          } else if (response.status === 'KO') {
            if (response.step === 'request') {
              param.webSocket.recording = false;
              param.webSocket.audioInput.disconnect(param.webSocket.recorder);
              param.webSocket.recorder.disconnect(param.webSocket.audioContext.destination);
              param.webSocket.audioContext.close();
              param.webSocket.audioContext = null;
              param.webSocket.audioInput = null;
              param.webSocket.recorder = null;
              reject(JSON.stringify(response.message));
            }
          }
        };
      }, function () {
        reject('Your microphone is not reachable.');
      });
      //  navigator
    }
  });
}

function stopRec(param) {
  if (!param.webSocket.audioInput) {
    if (param.debug === true) {
      console.log('you need to start the process before stoping it ');
    }
  } else {
    if (param.debug === true) {
      console.log('Stop Recording');
    }
    param.webSocket.recording = false;
    param.webSocket.audioInput.disconnect(param.webSocketrecorder);
    param.webSocket.recorder.disconnect(param.webSocket.audioContext.destination);
    param.webSocket.audioContext.close();
    param.webSocket.audioContext = null;
    param.webSocket.audioInput = null;
    param.webSocket.recorder = null;
    param.webSocket.audioTracks.getAudioTracks()[0].stop();

    if (param.language !== 'en' && param.language !== 'fr') {
      param.language = 'en';
    }
    param.webSocket.ws.send(JSON.stringify(['action', 'analyze', param.language]).toString());
    param.webSocket.ws.onclose = function () {
      param.webSocket.ws.close();
    };
  }
}

module.exports = {
  startRec: startRec,
  stopRec: stopRec
};